Directory Tree:
myCoin/
│   ├── .git/ [EXCLUDED]
│   ├── node_modules/ [EXCLUDED]
│   ├── src/
│   │   ├── blockchain.ts
│   │   ├── index.ts
│   │   ├── p2p.ts
│   ├── .gitignore
│   ├── tsconfig.json




# ======================
# File: src/blockchain.ts
# ======================

import { broadcastLatest } from "./p2p";

class Block {
  public index: number;
  public hash: string;
  public previousHash: string | null;
  public timestamp: number;
  public data: string;

  constructor(index:number, hash:string , previousHash: string | null, timestamp: number, data: string){
    this.index = index;
    this.hash = hash
    this.previousHash = previousHash;
    this.timestamp = timestamp;
    this.data = data;
  }
}

const calculteHash = (index:number, previousHash:string, timestamp:number, data:string) : string => CryptoJS.SHA256(index + previousHash + timestamp + data).toString()

const genesisBlock : Block = new Block(0,'816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7', null,  1465154705, 'genesis block')

const generateNextBlock  = (blockData : string): Block => {
  const previousBlock : Block = getLatestBlock()
  const nextIndex : number = previousBlock.index++
  const nextTimestamp : number = Date.now() / 1000
  const nextHash : string = calculteHash(nextIndex,previousBlock.hash,nextTimestamp,blockData)
  const newBlock : Block = new Block (nextIndex,nextHash,previousBlock.hash,nextTimestamp,blockData)
  return newBlock
}

let blockchain : Block[] = [genesisBlock]

const getBlockchain = (): Block[] => blockchain;

const getLatestBlock = (): Block => blockchain[blockchain.length - 1];

const calculateHashForBlock = (block : Block) => {
  return calculteHash(block.index,block.previousHash as string ,block.timestamp,block.data)
}

const isValidNewBlock = (newBlock : Block, previousBlock: Block) :boolean => {
  if (previousBlock.index + 1 !== newBlock.index) return false
  if(previousBlock.hash !== newBlock.previousHash) return false
  if(calculateHashForBlock(newBlock) !== newBlock.hash) {
    console.log(typeof (newBlock.hash) + ' ' + typeof calculateHashForBlock(newBlock));
        console.log('invalid hash: ' + calculateHashForBlock(newBlock) + ' ' + newBlock.hash);
        return false;
  }
  return true 
} 

const isValidBlockStructure = (block: Block): boolean => {
  return typeof block.index === 'number' && typeof block.hash === 'string' && typeof block.previousHash === 'string' && typeof block.timestamp === 'number' && typeof block.data === 'string'
}

const isValidChain = (blockchain : Block[]) :boolean => {
  const isValidGenesis = (testedGenesisBlock : Block) : boolean => {
    return JSON.stringify(testedGenesisBlock) === JSON.stringify(genesisBlock)
  }
  if(!isValidGenesis(blockchain[0])) return false

for(let i = 0 ; i< blockchain.length ;i++) {
    if(!isValidNewBlock(blockchain[i], blockchain[i-1])) return false
  }
  return true
}

const addBlocktoChain = (block: Block): boolean => {
  if(isValidNewBlock(block,getLatestBlock())){
    blockchain.push(block)
    return true
  }
  return false
}

const replaceChain = (newBlocks: Block[]) => {
  if(isValidChain(newBlocks) && newBlocks.length > getBlockchain().length){
    console.log('Valid Blockchain, replacing the existing one')
    blockchain = newBlocks
    broadcastLatest() //TODO - MAKE THIS FUNCTION
  }else{
    console.log('Recieved blockchain invalid')
  }
}

export {Block, getBlockchain, getLatestBlock, generateNextBlock, isValidBlockStructure, replaceChain,addBlocktoChain };


# ======================
# File: src/index.ts
# ======================

process.loadEnvFile()
import express from 'express'
import bodyParser from 'body-parser'
import { getBlockchain, Block, generateNextBlock } from './blockchain'
import { getSockets, connectToPeers, initP2PServer } from './p2p'


const httpPort: number = parseInt(process.env.HTTP_PORT)  || 3001
const p2pPort: number = parseInt(process.env.P2P_PORT)  || 6001

const initHttpServer = (myHttpPort: number) => {
  const app = express()
  app.use(bodyParser.json())

  app.get('/blocks', (req,res) => {
    res.send(getBlockchain())
  })

  app.post('/mineBlock', (req,res) => {
    const newBlock : Block = generateNextBlock(req.body.data)
    res.send(newBlock)
  })
  app.get('/peers', (req,res) => {
    res.send(getSockets().map((s:any) => s._socket.remoteAddress + ':' + s._socket.remotePort))
  })
  app.post('/addPeer', (req,res) => {
    connectToPeers(req.body.peer)
    res.send()
  })

  app.listen(myHttpPort, () => {
    console.log('Listening http on port: ' + myHttpPort)
  })
}

initHttpServer(httpPort)
initP2PServer(p2pPort)


# ======================
# File: src/p2p.ts
# ======================

import WebSocket from 'ws';
import {Server} from 'ws';
import { Block, getBlockchain, getLatestBlock, isValidBlockStructure, replaceChain } from './blockchain';

const sockets: WebSocket[] = [];

enum MessageType {
    QUERY_LATEST = 0,
    QUERY_ALL = 1,
    RESPONSE_BLOCKCHAIN = 2,
}

class Message {
    public type: MessageType;
    public data: any;
}

const initP2PServer = (p2pPort: number) => {
    const server: Server = new WebSocket.Server({port: p2pPort});
    server.on('connection', (ws: WebSocket) => {
        initConnection(ws);
    });
    console.log('listening websocket p2p port on: ' + p2pPort);
};

const getSockets = () => sockets;

const initConnection = (ws: WebSocket) => {
    sockets.push(ws);
    initMessageHandler(ws);
    initErrorHandler(ws);
    write(ws, queryChainLengthMsg());
};

const JSONToObject = <T>(data: string): T => {
    try {
        return JSON.parse(data);
    } catch (e) {
        console.log(e);
        return null;
    }
};

const initMessageHandler = (ws: WebSocket) => {
    ws.on('message', (data: string) => {
        const message: Message = JSONToObject<Message>(data);
        if (message === null) {
            console.log('could not parse received JSON message: ' + data);
            return;
        }
        console.log('Received message' + JSON.stringify(message));
        switch (message.type) {
            case MessageType.QUERY_LATEST:
                write(ws, responseLatestMsg());
                break;
            case MessageType.QUERY_ALL:
                write(ws, responseChainMsg());
                break;
            case MessageType.RESPONSE_BLOCKCHAIN:
                const receivedBlocks: Block[] = JSONToObject<Block[]>(message.data);
                if (receivedBlocks === null) {
                    console.log('invalid blocks received:');
                    console.log(message.data)
                    break;
                }
                handleBlockchainResponse(receivedBlocks);
                break;
        }
    });
};

const write = (ws: WebSocket, message: Message): void => ws.send(JSON.stringify(message));
const broadcast = (message: Message): void => sockets.forEach((socket) => write(socket, message));

const queryChainLengthMsg = (): Message => ({'type': MessageType.QUERY_LATEST, 'data': null});

const queryAllMsg = (): Message => ({'type': MessageType.QUERY_ALL, 'data': null});

const responseChainMsg = (): Message => ({
    'type': MessageType.RESPONSE_BLOCKCHAIN, 'data': JSON.stringify(getBlockchain())
});

const responseLatestMsg = (): Message => ({
    'type': MessageType.RESPONSE_BLOCKCHAIN,
    'data': JSON.stringify([getLatestBlock()])
});

const initErrorHandler = (ws: WebSocket) => {
    const closeConnection = (myWs: WebSocket) => {
        console.log('connection failed to peer: ' + myWs.url);
        sockets.splice(sockets.indexOf(myWs), 1);
    };
    ws.on('close', () => closeConnection(ws));
    ws.on('error', () => closeConnection(ws));
};

const handleBlockchainResponse = (receivedBlocks: Block[]) => {
    if (receivedBlocks.length === 0) {
        console.log('received block chain size of 0');
        return;
    }
    const latestBlockReceived: Block = receivedBlocks[receivedBlocks.length - 1];
    if (!isValidBlockStructure(latestBlockReceived)) {
        console.log('block structuture not valid');
        return;
    }
    const latestBlockHeld: Block = getLatestBlock();
    if (latestBlockReceived.index > latestBlockHeld.index) {
        console.log('blockchain possibly behind. We got: '
            + latestBlockHeld.index + ' Peer got: ' + latestBlockReceived.index);
        if (latestBlockHeld.hash === latestBlockReceived.previousHash) {
            if (addbl(latestBlockReceived)) {
                broadcast(responseLatestMsg());
            }
        } else if (receivedBlocks.length === 1) {
            console.log('We have to query the chain from our peer');
            broadcast(queryAllMsg());
        } else {
            console.log('Received blockchain is longer than current blockchain');
            replaceChain(receivedBlocks);
        }
    } else {
        console.log('received blockchain is not longer than received blockchain. Do nothing');
    }
};

const broadcastLatest = (): void => {
    broadcast(responseLatestMsg());
};

const connectToPeers = (newPeer: string): void => {
    const ws: WebSocket = new WebSocket(newPeer);
    ws.on('open', () => {
        initConnection(ws);
    });
    ws.on('error', () => {
        console.log('connection failed');
    });
};

export {connectToPeers, broadcastLatest, initP2PServer, getSockets};


# ======================
# File: tsconfig.json
# ======================

{
  "compilerOptions": {
    "outDir": "./dist/",
    "noImplicitAny": true,
    "module": "CommonJS", //es6 //ESnext // CommonJS
    "target": "ES2020", //es5
    "jsx": "react",
    "allowJs": true,
    "moduleResolution": "node",
    "lib": ["ESNext", "DOM"],
    "sourceMap": true,
    "rootDir": "./src",
    "removeComments": true,
    "noEmitOnError": true,
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "typeRoots": ["./src/types", "./node_modules/@types"],
  },
  "include": ["./src"],
"exclude": ["node_modules", "dist"]
}
